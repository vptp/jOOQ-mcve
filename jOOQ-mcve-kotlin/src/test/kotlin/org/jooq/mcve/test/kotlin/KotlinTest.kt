package org.jooq.mcve.test.kotlin

import com.zaxxer.hikari.HikariConfig
import com.zaxxer.hikari.HikariDataSource
import org.jooq.DSLContext
import org.jooq.SQLDialect
import org.jooq.impl.DSL
import org.jooq.impl.DataSourceConnectionProvider
import org.jooq.impl.DefaultConfiguration
import org.jooq.impl.ThreadLocalTransactionProvider
import org.jooq.mcve.kotlin.tables.daos.TestDao
import org.jooq.mcve.kotlin.tables.pojos.TestPojo
import org.jooq.mcve.kotlin.tables.references.TEST
import org.junit.After
import org.junit.Before
import org.junit.Test

class KotlinTest {

    var connectionPool: HikariDataSource? = null
    var ctx: DSLContext? = null

    @Before
    fun setup() {
        val hikariConfig = HikariConfig().apply {
            jdbcUrl = "jdbc:sqlite:${System.getProperty("user.home")}/jooq-mcve-kotlin-2.sqlite3"
            maximumPoolSize = 1 // Single connection for sqlite database
            connectionTimeout = 1000 // Short to make test fail faster
        }
        connectionPool = HikariDataSource(hikariConfig)
        val connectionProvider = DataSourceConnectionProvider(connectionPool)

        val config = DefaultConfiguration().apply {
            set(SQLDialect.SQLITE)
            set(ThreadLocalTransactionProvider(connectionProvider))
        }
        ctx = DSL.using(config)

        ctx().delete(TEST).execute()
    }

    @After
    fun after() {
        ctx = null
        connectionPool?.close()
        connectionPool = null
    }

    fun ctx(): DSLContext = ctx!!

    @Test
    fun mcveTestInsertInsideTransaction() {
        val testDao = TestDao(ctx().configuration())
        ctx().transaction { -> // No lambda arg to force ContextTransactionalRunnable for thread local context
            testDao.insert(TestPojo(null, 42)) // This succeeds
        }
    }

    @Test
    fun mcveTestInsertOutsideTransaction() {
        val testDao = TestDao(ctx().configuration())
        testDao.insert(TestPojo(null, 42)) // This fails
    }
}